<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>TypeScript 101</title>
    <link rel="shortcut icon" href="./favicon.ico"/>
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="./dist/theme/black.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/zenburn.css" />

  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section  data-markdown><script type="text/template"># TypeScript 101

a **very** lightweight introduction

</script></section><section  data-markdown><script type="text/template"># Topics

- Static Typing
- Typescript
- Types
- Operators
- Generics
- Type Narrowing
- Advanced Features
- Tooling
- Errors
- Common Mistakes

</script></section><section  data-markdown><script type="text/template"># Non Topics

- Project Setup
- Compiler Configuration
- Debugging

</script></section><section ><section data-markdown><script type="text/template"># Static Typing

</script></section><section data-markdown><script type="text/template">## What is this?

A way to tell how the data looks like at compile time.

Example with Java:

```java
String name = "John Doe";
```

</script></section><section data-markdown><script type="text/template">## Why is this important?

- allows static analysis and type safety verification
- minimizes the possibility of type errors in run time
- improves instant feedback while developing
- improves IDE capabilities
  - no more find/replace to refactor

<aside class="notes"><ul>
<li>does not require to run the program</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">## Static Typings in Other Languages

- it is what it is
  - typescript is highly configurable
- either mandatory or non existent
  - optional in typescript but highly recommended, that's why we are here

<aside class="notes"><ul>
<li>considering only the more mainstream languages</li>
</ul>
</aside></script></section></section><section ><section data-markdown><script type="text/template"># Typescript

</script></section><section data-markdown><script type="text/template">## What is TypeScript

- A programming language, pretty obvious here
- Superset of JS
- Second "most loved" programming language in 2020
- Maintained by Microsoft

<aside class="notes"><ul>
<li>any JavaScript code is also TypeScript code</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">## What is not?

- A magical way of fixing all of our problems
- Executed at runtime
- A passing trend
- A replacement for unit tests

</script></section><section data-markdown><script type="text/template">## Transpiler? Errr... What?

- compiler
  - transforms one language into another
    - usualy machine code
- transpiler
  - a type of compiler
  - produces human readable source code

<aside class="notes"><ul>
<li>the TypeScript compiler produces human readable JavaScript that can be further processed and optimized</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">## Type Inference

- explicit typing
  - the source code describes the types
- implicit typing
  - the compiler infers types from the existing source code

</script></section><section data-markdown><script type="text/template">## Type Compatibility

Type compatibility in TypeScript is based on structural typing.

```typescript
interface Pet {
  name: string;
}
class Dog {
  name: string;
}
let pet: Pet;
// OK, because of structural typing
pet = new Dog();
```

this is also called duck typing 🦆

> if it walks like a duck and it quacks like a duck, then it must be a duck

<aside class="notes"><ul>
<li>in contrast with nominal typing, like C or Java</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">## Pros / Cons

Pros:

- can be adopted gradually
- any JavaScript code is also TypeScript code
- rich IDE support
- awesome support for TSX (JSX + TypeScript)
- can make tests easier to write

Cons:

- adds an extra effort to the development process
- typings can get pretty complex
- third-party typings are not always up to date

</script></section></section><section ><section data-markdown><script type="text/template"># Types

`let variable: Type = value;`

![](./assets/typing-syntax.svg)

<aside class="notes"><pre><code class="language-bnf">Diagram(
  Optional(
    Choice(0,
      Terminal(&#39;const&#39;),
      Terminal(&#39;let&#39;),
      Terminal(&#39;var&#39;),
    ),
  ),
  NonTerminal(&#39;identifier&#39;),
  Optional(
    Sequence(
      Terminal(&#39;:&#39;),
      NonTerminal(&#39;type reference&#39;)
    )
  ),
  Optional(
    Sequence(
      Terminal(&#39;=&#39;),
      NonTerminal(&#39;value&#39;)
    )
  ),
  Optional(
    Terminal(&#39;;&#39;)
  ),
)
</code></pre>
</aside></script></section><section data-markdown><script type="text/template">## primitive types

```typescript
const y: number = 42;
```

```typescript
const name: string = "foobar";
```

```typescript
const isSomething: boolean = true;
```

<aside class="notes"><ul>
<li>using type annotations together with the initialization is redundant and unnecessary<ul>
<li>the compiler can infer the type</li>
</ul>
</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">## primitive types

```typescript
const x = 27;
```

```typescript
const name = "foo";
```

```typescript
const isSomething = true;
```

</script></section><section data-markdown><script type="text/template">## arrays

```typescript
const words: string[] = ["Foo", "Bar"];
```

```typescript
const words: Array<string> = ["Foo", "Bar"];
```

</script></section><section data-markdown><script type="text/template">## tuples

```typescript
const tuple: [string, number] = ["FooBar", 27];
```

</script></section><section data-markdown><script type="text/template">## functions

```typescript
function formatPrice(fn: (v: number) => string): string {}
```

</script></section><section data-markdown><script type="text/template">## objects

```typescript
function printName(obj: { first: string; last?: string }) {
  // ...
}
```

```typescript
printName({ first: "John", last: "Doe" });
printName({ first: "Bob" });
```

</script></section><section data-markdown><script type="text/template">## any

its like saying

> please turn off type checking for this thing

<aside class="notes"><ul>
<li>it allows everything that’s syntactically legal</li>
<li>please don’t use it</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">## unknown

similar to the any type, but is safer because it’s not legal to do anything with an unknown value

```typescript
let maybe: unknown;
```

requires type guards to access the value

```typescript
if (typeof maybe === "string") {
  // maybe is a string
}
```

</script></section><section data-markdown><script type="text/template">## void

used for functions returning `void`

```typescript
function noop(): void {}
```

```typescript
function noop() {}
```

```typescript
function noop() {
  return;
}
```

</script></section><section data-markdown><script type="text/template">## never

some functions `never` return a value

```typescript
function fail(msg: string): never {
  throw new Error(msg);
}
```

</script></section><section data-markdown><script type="text/template">## type arithmetics

a way to build new types from existing ones using operators

- unions
- intersections

</script></section><section data-markdown><script type="text/template">### union types

```typescript
function draw(shape: Square | Circle) {}
```

</script></section><section data-markdown><script type="text/template">### intersection types

```typescript
function draw(shape: Shape & Colorful) {}
```

</script></section><section data-markdown><script type="text/template">## type aliases

a way to define a new type to be used in other places

```typescript
type Person = {
  name: string;
  age: number;
  height?: number;
};
```

```typescript
type Shape = Square | Circle;
```

</script></section><section data-markdown><script type="text/template">## interfaces

```typescript
interface Person {
  name: string;
  age: number;
  height?: number;
}
```

</script></section><section data-markdown><script type="text/template">## type aliases vs interfaces

- declaration merging
  - type aliases cannot be re-opened to add new properties
  - an interface is always extendable
- functionality
  - interfaces can only describe the structure of objects and functions
  - type aliases can also rename primitives
- interfaces can be used as contracts
- interfaces can not describe union types

</script></section><section data-markdown><script type="text/template">### what should I use?

The recommended way to define a type is to use `interface`, at least until you need to use features from `type`.

</script></section><section data-markdown><script type="text/template">## literal types

```typescript
type Alignment = "left" | "center" | "right";
```

</script></section><section data-markdown><script type="text/template">## Enums

```typescript
enum Direction {
  Left,
  Right,
} // Left === 0, Right === 1
```

```typescript
enum Direction {
  Left = "LEFT",
  Right = "RIGHT",
}
```

<aside class="notes"><ul>
<li>since this is not supported in JavaScript, the compiler adds some runtime code</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">## type assertions

```typescript
let strLength: number = (someValue as string).length;
```

```typescript
let strLength: number = (<string>someValue).length;
```

its like saying

> trust me, I know what I’m doing

<aside class="notes"><ul>
<li>Similar to a cast in other languages</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">## classes

```typescript
class Person {
  name: string;
  age: number;
  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
}
```

</script></section><section data-markdown><script type="text/template">### field modifiers

`readonly`

```typescript
class Person {
  readonly name: string;
}
```

`?` (optional)

```typescript
class Person {
  name: string;
  age?: number;
}
```

</script></section><section data-markdown><script type="text/template">### member visibility

`public` | `private` | `protected`

```typescript
class Person {
  public title: string;
  public name: string;
  private age: number;

  constructor(name: string, age: number, title: string) {
    this.name = name;
    this.age = age;
    this.title = title;
  }

  public getFullName(): string {}
}
```

</script></section><section data-markdown><script type="text/template">### static members

```typescript
class Person {
  static getFullName(person: Person): string {
    return person.name + " " + person.title;
  }
}

Person.getFullName({ name: "John", title: "Mr." });
```

</script></section><section data-markdown><script type="text/template">### class heritage

```typescript
abstract class Person extends Being implements Serializable {
  static species = "Homo sapiens";
  name: string;

  constructor(name: string) {
    super(Person.species);
  }

  serialize(): string {
    return JSON.stringify(this);
  }
}
```

</script></section></section><section ><section data-markdown><script type="text/template"># Operators

(for manipulating types)

<aside class="notes"><ul>
<li>the following operators are just a subset of the ones supported by TypeScript</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">## keyof

```typescript
type Point = { x: number; y: number };
type P = keyof Point; // P = "x" | "y"
```

</script></section><section data-markdown><script type="text/template">## typeof

```typescript
type Point = { x: number; y: number };
let p: Point = { x: 1, y: 2 };
let cType: typeof p.x; // cType = number
```

</script></section><section data-markdown><script type="text/template">## indexed access type

```typescript
type Person = { age: number; name: string; alive: boolean };
type Age = Person["age"]; // Age = number
```

</script></section></section><section ><section data-markdown><script type="text/template"># Generics

a way describe meaningful type dependencies

- Class instance members
- Class methods
- function arguments
- function return value

<aside class="notes"><ul>
<li>this allows us to write code that is type safe and reusable</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">## Generic Functions

```typescript
function firstElement<Type>(arr: Type[]): Type {
  return arr[0];
}
```

```typescript
function firstElement<T>(arr: T[]): T {
  return arr[0];
}
```

```typescript
const s = firstElement(["a", "b", "c"]); // s is a string

const n = firstElement([1, 2, 3]); // n is a number
```

</script></section><section data-markdown><script type="text/template">## Generic Classes

```typescript
class Box<C> {
  contents: C[] = [];

  add(content: C) {
    this.contents.push(content);
  }

  getLast(): C | undefined {
    return this.contents.pop();
  }
}
```

</script></section><section data-markdown><script type="text/template">## Type Parameters with Constraints

```typescript
function getProperty<Type, Key extends keyof Type>(obj: Type, key: Key) {
  return obj[key];
}

let x = { a: 1, b: 2, c: 3, d: 4 };

getProperty(x, "a");
getProperty(x, "m"); // not allowed
```

</script></section></section><section ><section data-markdown><script type="text/template"># Type Narrowing

inferring the type of a variable by narrowing down the amount of types it can be

```typescript
let someValue: number | string | undefined;
```

this is done with type guards

</script></section><section data-markdown><script type="text/template">## typeof

```typescript
if (typeof someValue === "string") {
  // do something with the string
}
```

</script></section><section data-markdown><script type="text/template">## truthiness

```typescript
if (someValue) {
  // do something
}
```

</script></section><section data-markdown><script type="text/template">## equality

```typescript
function example(x: string | number, y: string | boolean) {
  if (x === y) {
    // We can now call any 'string' method on 'x' or 'y'.
  }
}
```

</script></section><section data-markdown><script type="text/template">## in

```typescript
type Fish = { swim: () => void };
type Bird = { fly: () => void };

function move(animal: Fish | Bird) {
  if ("swim" in animal) {
    return animal.swim();
  }

  return animal.fly();
}
```

</script></section><section data-markdown><script type="text/template">## instanceof

```typescript
function logValue(x: Date | string) {
  if (x instanceof Date) {
    console.log(x.toUTCString());
  } else {
    console.log(x.toUpperCase());
  }
}
```

</script></section><section data-markdown><script type="text/template">## assignment

```typescript
let x: number | string = "foo";
x = "bar";
// x is now a string
x = 1;
// x is now a number
```

</script></section><section data-markdown><script type="text/template">## type predicates

```typescript
function isFish(pet: Fish | Bird): pet is Fish {
  return (pet as Fish).swim !== undefined;
}
```

```typescript
const pet = getSmallPet();

if (isFish(pet)) {
  pet.swim();
} else {
  pet.fly();
}
```

</script></section><section data-markdown><script type="text/template">## discriminated unions

```typescript
interface Circle {
  kind: "circle";
  radius: number;
}

interface Square {
  kind: "square";
  sideLength: number;
}

type Shape = Circle | Square;
```

```typescript
function getArea(shape: Shape) {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius * shape.radius;
    case "square":
      return shape.sideLength * shape.sideLength;
  }
}
```

</script></section></section><section ><section data-markdown><script type="text/template"># Advanced Features

(just a sneak peek)

</script></section><section data-markdown><script type="text/template">## Function Overloading

```typescript
function connect(dest: Destination): Connection;
function connect(host: string, port: number): Connection;
function connect(
  destOrHost: string | Destination, // any type of the above
  port?: number // optional
): Connection {
  if (typeof destOrHost === "string") {
    // do something with host and port
  } else {
    // do something with a destination
  }
}
```

```typescript
const c1 = connect("localhost", 80);
const c2 = connect({ host: "localhost", port: 80 });
```

<aside class="notes"><ul>
<li>the order of the overloads should be from the most specific to the least specific</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">## Types for Third-Party Libraries

allows TypeScript compiler to validate calls to external code

get existing types

```sh
npm install --save @types/some-lib
```

implement your own

```typescript
declare namespace 'some-lib' {
  function makeSomething(s: string): string;
  let numberOfThings: number;
}
```

<aside class="notes"><ul>
<li>most libraries have typings available in the npm registry</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">## Decorators

- a way to add
  - annotations
  - meta-programming syntax for class declarations and members

```typescript
@sealed
class Test {
  @format("yyyy-MM-dd")
  date: string;

  @measure
  @memoize
  computeX(@required arg: string) {}
}
```

<aside class="notes"><ul>
<li>decorators can be composed</li>
<li>decorator factories can receive parameters (<code>format</code>)</li>
<li>decorators can be attached to<ul>
<li>class declaration</li>
<li>class members: fields, methods, accessors</li>
<li>method parameters</li>
</ul>
</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">## Mixins

A mixin is a function that

1. takes a constructor,
2. creates a class that extends that constructor with new functionality
3. returns the new class

```typescript
function Timestamped<T extends Constructor>(Base: T) {
  return class extends Base {
    timestamp = Date.now();
  };
}
```

```typescript
const TimestampedPerson = Timestamped(Person);
const tp = new TimestampedPerson();
```

<aside class="notes"><ul>
<li>since both TypeScript and JavaScript do not support multiple inheritance, mixins can be used to implement a kind of multiple inheritance</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">## Transformers

a way to transform code programatically

```typescript
const Transformer = (code) => code;
```

⚠️ Here be dragons... And ASTs.

</script></section></section><section ><section data-markdown><script type="text/template"># Tooling

</script></section><section data-markdown><script type="text/template">## TSC

TSC is the TypeScript Compiler

- compiles TypeScript to JavaScript
- configurable via `tsconfig.json`

```sh
npm install -g typescript
```

```sh
tsc index.ts # compiles index.ts to index.js
```

</script></section><section data-markdown><script type="text/template">## ts-node

`ts-node` is a TypeScript execution engine and REPL for Node.js.

```sh
npm install -g typescript
```

```sh
ts-node index.ts # compiles index.ts and runs it
```

<aside class="notes"><ul>
<li><code>ts-node</code> can be used to debug TypeScript code, in VSCode for example</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">## Visual Studio Code

~~A Code Editor~~ The Code Editor

- awesome editor
- built-in TypeScript support with autocomplete
- built-in debugger

https://code.visualstudio.com/

</script></section><section data-markdown><script type="text/template">## deno

A secure runtime for JavaScript and TypeScript.

- secure by default
- supports TypeScript out of the box

https://deno.land/

<aside class="notes"><ul>
<li>could not end this list without talking about deno</li>
<li>think of deno as a way of Ryan Dahl asking for forgiveness</li>
</ul>
</aside></script></section></section><section ><section data-markdown><script type="text/template"># Errors

when something wrong is not right

<aside class="notes"><ul>
<li>sometimes the errors look a little bit cryptic</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">## Interpreting Errors

```plaintext
Argument of type '{ foo: number; bar: () => string; }' is not
assignable to parameter of type 'SomethingComplex'.
  Types of property 'bar' are incompatible.
    Type '() => string' is not assignable to type 'string'.
```

Digesting the error

What?

the description of the error is in the first line

Why?

starting in line 2, there is a chain of causes of the error

<aside class="notes"><ul>
<li>these error stacks can get really long</li>
<li>in this case, by steps:<ul>
<li>line 1, we are trying to use an object as an argument to a function that has an parameter of type <code>SomethingComplex</code></li>
<li>line 2: the incompatibility is in the property <code>bar</code></li>
<li>line 3: the value the property <code>bar</code> in the argument is a function that returns a string, but the parameter expects an object with a <code>bar</code> property that is a string</li>
</ul>
</li>
</ul>
</aside></script></section></section><section  data-markdown><script type="text/template"># Common Mistakes

- not using strict mode
- messing with the type inference
  - using `any`
- use `Function`
  - it means "any function"
- use the wrapper objects instead of the primitives
  - `number` vs `Number`

</script></section><section  data-markdown><script type="text/template"># Want to Learn More?

- [Official Typescript documentation](https://www.typescriptlang.org/)
- Online Courses
  - Understanding TypeScript - 2021 Edition (Udemy)
- Contribute to an existing project

<aside class="notes"><ul>
<li>official documentation includes a playground</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template"># Q & A

</script></section><section  data-markdown><script type="text/template"># Thanks
</script></section></div>
    </div>

    <script src="./dist/reveal.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"transition":"slide","progress":true}, queryOptions);
    </script>


    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
